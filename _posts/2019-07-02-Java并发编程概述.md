---
layout:     post
title:      Java并发编程概述
subtitle:   Java并发编程概述
date:       2019-07-02
author:     gregorius
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - 分布式
---

### 计算机缓存体系

![](https://upload-images.jianshu.io/upload_images/10824258-e28afa5e62ac0afe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

字：一个word的意思，IA32中指的是16位，

块：是一个固定大小的信息包，在高速缓存和主存之间来回传送。块包含32~64个字节。所以内存中只是信息，成为块

行：高速缓存中存储块已经其他信息的容器。所以，行总是一个块的大小，通常“行”和“块”可以互换使用。结合上图高速缓存既有块和其他信息，称之为“行”

组：是一个或者多个行

![](https://upload-images.jianshu.io/upload_images/10824258-1bb209b630ec070f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


&emsp;&emsp;由于CPU和主存的处理速度上存在一定差别，为了匹配这种差距，提升计算机能力，人们在CPU和主存之间增加了多层高速缓存。每个CPU会有L1、L2甚至L3缓存，在多核计算机中会有多个CPU，那么就会存在多套缓存，那么这多套缓存之间的数据就可能出现不一致的现象。为了解决这个问题，有了内存模型。内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。

##### 缓存一致性问题

首先，缓存一致性是由于引入缓存而导致的问题，所以，这是很多CPU厂商必须解决的问题。为了解决前面提到的缓存数据不一致的问题，人们提出过很多方案，通常来说有以下2种方案：

1、通过在总线加LOCK#锁的方式。

2、通过缓存一致性协议（Cache Coherence Protocol）。

LOCK#锁

因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从其内存读取变量，然后进行相应的操作。

##### **缓存一致性协议**

最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。

MESI的核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。

在MESI协议中，每个缓存可能有有4个状态，它们分别是：

**M(Modified)**：这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。

**E(Exclusive)**：这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。

**S(Shared)**：这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。

**I(Invalid)**：这行数据无效。

![](https://upload-images.jianshu.io/upload_images/10824258-a713291a81db37ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&emsp;&emsp;当一个CPU进行写入时，首先会给其它CPU发送Invalid消息，然后把当前写入的数据写入到Store Buffer中。然后异步在**某个时刻**真正的写入到Cache中。当前CPU核如果要读Cache中的数据，需要先扫描Store Buffer之后再读取Cache。但是此时其它CPU核是看不到当前核的Store Buffer中的数据的，要等到Store Buffer中的数据被刷到了Cache之后才会触发失效操作。而当一个CPU核收到Invalid消息时，会把消息写入自身的Invalidate Queue中，随后**异步**将其设为Invalid状态。

##### **处理器优化和指令重排**

&emsp;&emsp;上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在**缓存一致性问题**。除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是**处理器优化**。

&emsp;&emsp;除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做**指令重排**。

&emsp;&emsp;可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。

&emsp;&emsp;**为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。**通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。

&emsp;&emsp;在执行程序时，为了提高性能，编译器和处理器常常会对指合做重排序。重排序分3种类型。

- (1)编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

- (2)指令级并行的重排序。现代处理器采用了指级并行技术（Imstruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

- (3)内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

&emsp;&emsp;内存模型解决并发问题主要采用两种方式：**限制处理器优化**和**使用内存屏障**

&emsp;&emsp;上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指，通过内存屏障指令来禁止特定类型的处理器重排序。

内存屏障类型：

![](https://upload-images.jianshu.io/upload_images/10824258-e83a701fda4e2e31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

常见处理器允许的重排序类型：

![](https://upload-images.jianshu.io/upload_images/10824258-0f9c0ed57e8a7c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序

### Java内存模型

&emsp;&emsp;**当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。**

&emsp;&emsp;**Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。**

&emsp;&emsp;Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。

![](https://upload-images.jianshu.io/upload_images/10824258-7ecfc838533ac6b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

&emsp;&emsp;这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。

##### Volatile原理

&emsp;&emsp;为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指，将这个变量所在缓存行的数写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

volatile的两条实现原则：

- 1）Lock前缀指会引起处理器缓存回写到内存。Lock前缀指合导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK#信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。对于Intel486和Pentium处理器，在锁操作时，总是在总线上声言LOCK#信号。但在P6和目前的处理器中，如果访问的内存区域已经缓存在处理器内部，则不会声言LOCK#信号。相反，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。

- 2）一个处理器的缓存回写到内存会导致其他处理器的缓存无效。IA-32处理器和Intel64处理器使用MESI（修改、独占、共享、无效）控制协议去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32和Intel64处理器能嗅探其他处理器访问系统内存和它们的内部缓存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。例如，在Pentium和P6family处理器中，如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。

##### synchronized的实现原理与应用

&emsp;&emsp;在多线程并发编程中synchronized一直是元老级角色，很多人都会称呼它为重量级锁。但是，随着Java SE 1.6对synchronized进行了各种优化之后，有些情况下它就并不那么重了。本文详细介绍JavaSE1.6中为了减少获得锁和释放锁带来的性能消耗而引人的偏向锁和轻量级锁，以及锁的存储结构和升级过程。

###### Java对象头

&emsp;&emsp;每个Java对象都可以隐式地扮演一个用于同步的锁的角色；这些内置的锁被称作内部锁（intrinsic locks）或监视器锁（monitor locks）。执行线程进入synchronized块之前会自动获得锁；而无论通过正常控制路径退出，还是从块中抛出异常，线程都在放弃对synchronized 块的控制时自动释放锁。获得内部锁的唯一途径是：进入这个内部锁保护的同步块或方法。

&emsp;&emsp;内部锁在Java中扮演了互斥锁（mutual exclusion lock，也称作mutex）的角色，意味着至多只有一个线程可以拥有锁，当线程A尝试请求一个被线程B占有的锁时，线程A必须等待或者阻塞，直到B释放它。如果B永远不释放锁，A将永远等下去。

&emsp;&emsp;同一时间，只能有一个线程可以运行特定锁保护的代码块，因此，由同一个锁保护的synchronized块会各自原子地执行，不会相互干扰。在并发的上下文中，原子性的含义与它在事务性应用中相同——一组语句（statements）作为单独的，不可分割的单元运行。执行synchronized块的线程，不可能看到会有其他线程能同时执行由同一个锁保护的synchronized块。

&emsp;&emsp;synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit，如下所示。

- 32/64bit:Mark Word,存储对象的hashCode或锁信息等

- 32/64bit:Class Metadata Address,存储到对象类型数据的指针

- 32/32bit :Array length,数组的长度（如果当前对象是数组）

&emsp;&emsp;Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构如下所示。

- 锁状态:无锁状态

- 25bit:对象的hashCode

- 4bit:对象分代年龄

- 1bt是否是偏向锁:0

- 2bit锁标志位:01

在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据，如下所示。

![](https://upload-images.jianshu.io/upload_images/10824258-517698e9d5e63487.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下所示。

![](https://upload-images.jianshu.io/upload_images/10824258-43df2c235e6383c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。

- 对于普通同步方法，锁是当前实例对象。

- 对于静态同步方法，锁是当前类的Class对象。

- 对于同步方法块，锁是Synchonized括号里配置的对象。

&emsp;&emsp;当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。那么锁到底存在哪里呢？锁里面会存储什么信息呢？

&emsp;&emsp;从JVM规范中可以看到Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。

&emsp;&emsp;monitorenter指是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它处于锁定状态。线程执行到monitorenter指合时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

##### 锁的升级与对比

Java SE1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在JavaSE1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

###### 偏向锁

&emsp;&emsp;HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

###### 轻量级锁

CAS介绍

&emsp;&emsp;CAS（比较与交换，Compare and swap） 是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。实现非阻塞同步的方案称为“无锁编程算法”（ Non-blocking algorithm）。

- （1）轻量级锁加锁

线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并捋对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

- （2）轻量级锁解锁

轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

##### Final内存语义

&emsp;&emsp;final可以用于声明字段、方法和类。final声明字段时，若为基本类型，表示该变量值初始化后不再改变；若为引用类型，则表示引用不可变，但引用所指向的对象是可以改变的。final声明方法时表示方法不可覆写（常用来限制子类不可以改写父类中方法）。final声明类时，表示类不可继承，如String类就是final的，你不能继承它。

&emsp;&emsp;final字段的详细语义与普通字段稍有不同。尤其是，编译器有很大的自由，能将对final字段的读操作移到同步屏障之外，然后调用任意或未知的方法。同样，也允许编译器将final字段的值保存到寄存器，在非final字段需要重新加载的那些地方，final字段无需重新加载。另外，将对象声明为不可变的，则可实现并发访问，即final可提供一种非同步状态下 轻量级的 线程安全方法。

读final字段的重排序规则：

  &emsp;&emsp;在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如alpha处理器），这个规则就是专门用来针对这种处理器。

写final字段重排序规则：

   - JMM禁止编译器把final域的写重排序到构造函数之外。

  -  编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。写final字段的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final字段已经被正确初始化过了，而普通字段不具有这个保障。如果final字段是引用类型，则写final字段的重排序规则增加了以下约束：

-  在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。

final字段语义有以下几个目标：

- 1、final字段的值不会变化。编译器不应该因为获得了一个锁，读取了一个volatile变量或调用了一个未知方法，而重新加载一个final字段。

-  2、一个对象，仅包含final字段且在构建期间没有对其他线程可见，应当视作不可变的，即使这类对象的引用在线程间传递时存在数据争用。

- 3、将字段 f 设为final，在读取 f 时应当利用最小的编译器/架构代价。

- 4、该语义必须支持诸如反序列化等场景，在这种情况下，一个对象的final字段会在该对象构建完成后改变。

### Java中的锁

##### Lock接口

&emsp;&emsp;锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而JavaSE5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与symchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种symchronized关键字所不具备的同步特性。

&emsp;&emsp;使用synchronized关键字将会隐式地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放。当然，这种方式简化了同步的管理，可是扩展性没有显示的锁获取和释放来的好。例如，针对一个场景，手把手进行锁获取和释放，先获得锁A，然后再获取锁B，当锁B获得后，释放锁A同时获取锁C，当锁C获得后，再释放B同时获取锁D，以此类推。这种场景下，synchronized关键字就不那么容易实现了，而使用Lock却容易许多。

![](https://upload-images.jianshu.io/upload_images/10824258-46e6e79736d41c6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 队列同步器

&emsp;&emsp;队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。

&emsp;&emsp;同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。

同步队列的基本结构

![](https://upload-images.jianshu.io/upload_images/10824258-90b1b3f0d9c0dda4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 重入锁

重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。

ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock0方法时，已经获取到锁的线程，能够再次调用lock）方法获取锁而不被阻塞。

这里提到一个锁获取的公平性问题，如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。

事实上，公平的锁机制往往没有非公平的效率高，但是，并不是任何场景都是以TPS作为唯一的指标，公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。

##### 读写锁

之前提到锁（如Mutex和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。

除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。

### Volatile,锁比较

volatile变量固然方便，但也存在限制。它们通常被当作标识完成、中断、状态的标记使用。尽管volatile也可以用来标示其他类型的状态信息，但是决定这样做之前请格外小心。比如，volatile的语义不足以使自增操作（count++）原子化，除非你能保证只有一个线程对变量执行写操作。（原子变量提供了“读-改-写”原子操作的支持，而且常被用作“更优的volatile变量”。

加锁可以保证可见性与原子性；volatile变量只能保证可见性。

只有满足了下面所有的标准后，你才能使用volatile变量：

- 写入变量时并不依赖变量的当前值；或者能够确保只有单一的线程修改变量的值；

- 变量不需要与其他的状态变量共同参与不变约束；

- 而且，访问变量时，没有其他的原因需要加锁。

### Java并发容器和框架

##### ConcurrentHashMap

为什么要使用ConcurrentHashMap

- (1) 线程不安全的HashMap

在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。

- (2) 效率低下的Hash Table

Hashlable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下Hashlable的效率常低下。因为当一个线程访问Hashlable的同步方法，其他线程也访问HashTable的同步方法时，会进人阻塞或轮询状态。

- (3) ConcurrentHashMap的锁分段技术可有效提升并发访问率

Hashlable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

##### 阻塞队列

&emsp;&emsp;阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。

- 1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。

- 2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。

##### Fork/Join框架

&emsp;&emsp;Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。

##### Java中的线程池

Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。

- 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

- 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。

- 第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。

### Executor框架

&emsp;&emsp;在Java中，使用线程来异步执行任务。Java线程的创建与销毁需要一定的开销，如果我们为每一个任务创建一个新线程来执行，这些线程的创建与销毁将消耗大量的计算资源。同时，为每一个任务创建一个新线程来执行，这种策略可能会使处于高负荷状态的应用最终崩溃。

&emsp;&emsp;Java的线程既是工作单元，也是执行机制。从JDK5开始，把工作单元与执行机制分离开来。工作单元包括Rummable和Callable，而执行机制由Executor框架提供。

##### Executor框架的两级调度模型

&emsp;&emsp;在HotSpot VM的线程模型中，Java线程（java.lang.Thread）被一对一映射为本地操作系统线程。Java线程后动时会创建一个本地操作系统线程；当该Java线程终止时，这个操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的CPU。

&emsp;&emsp;在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。这种两级调度模型的示意图如图所示。

![](https://upload-images.jianshu.io/upload_images/10824258-9d59903c695b95e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


##### **Executor框架工作流程**

![](https://upload-images.jianshu.io/upload_images/10824258-171d962282520900.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 并发编程与设计模式

##### **生产者消费者模式**

&emsp;&emsp;生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。

##### Future模式

&emsp;&emsp;Future模式是多线程开发中非常常见的一种设计模式。它的核心思想是异步调用。当我们需要调用一个函数方法时。如果这个函数执行很慢,那么我们就要进行等待。但有时候,我们可能并不急着要结果。因此,我们可以让被调用者立即返回,让他在后台慢慢处理这个请求。对于调用者来说,则可以先处理一些其他任务,在真正需要数据的场合再去尝试获取需要的数据。

&emsp;&emsp;使用Future模式,获取数据的时候无法立即得到需要的数据。而是先拿到一个契约,你可以再将来需要的时候再用这个契约去获取需要的数据,这个契约就好比叫外卖的例子里的外卖订单。

##### 不变模式

&emsp;&emsp;在阎宏博士的《JAVA与模式》一书中开头是这样描述不变（Immutable）模式的：

&emsp;&emsp;*一个对象的状态在对象被创建之后就不再变化，这就是所谓的不变模式。**

###### 不变模式的结构

&emsp;&emsp;不变模式可增强对象的强壮型(robustness)。不变模式允许多个对象共享某一个对象，降低了对该对象进行并发访问时的同步化开销。如果需要修改一个不变对象的状态，那么就需要建立一个新的同类型对象，并在创建时将这个新的状态存储在新对象里。

&emsp;&emsp;不变模式只涉及到一个类。一个类的内部状态创建后，在整个生命周期都不会发生变化时，这样的类称作不变类。这种使用不变类的做法叫做不变模式。不变模式有两种形式：一种是弱不变模式，另一种是强不变模式。

##### **NIO**

&emsp;&emsp;Java NIO(New IO)是一个可以替代标准Java IO API的IO API(从Java1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。

&emsp;&emsp;所以Java NIO是一种新式的IO标准，与之间的普通IO的工作方式不同。标准的IO基于字节流和字符流进行操作的，而NIO是基于通道(Channel)和缓冲区(Buffer)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道也类似。

&emsp;&emsp;**由上面的定义就说明NIO是一种新型的IO，但NIO不仅仅就是等于Non-blocking IO（非阻塞IO），NIO中有实现非阻塞IO的具体类，但不代表NIO就是Non-blocking IO（非阻塞IO）。**

Java NIO 由以下几个核心部分组成：

- Buffer  
- Channel  
- Selector

&emsp;&emsp;传统的IO操作面向数据流，意味着每次从流中读一个或多个字节，直至完成，数据没有被缓存在任何地方。NIO操作面向缓冲区，数据从Channel读取到Buffer缓冲区，随后在Buffer中处理数据。

### 参考资料:

><<Java并发编程的艺术>>
<<JAVA并发编程实践>>
[https://blog.csdn.net/quanzhongzhao/article/details/45694711](https://blog.csdn.net/quanzhongzhao/article/details/45694711)
[https://blog.csdn.net/u012403290/article/details/64910926](https://blog.csdn.net/u012403290/article/details/64910926)
[https://blog.csdn.net/Roy_70/article/details/69799845](https://blog.csdn.net/Roy_70/article/details/69799845)
[https://www.infoq.cn/article/producers-and-consumers-mode](https://www.infoq.cn/article/producers-and-consumers-mode)
[https://blog.csdn.net/hherima/article/details/8934286](https://blog.csdn.net/hherima/article/details/8934286)
[https://www.hollischuang.com/archives/2662](https://www.hollischuang.com/archives/2662)
[http://www.hollischuang.com/archives/2550](http://www.hollischuang.com/archives/2550)
>[https://www.jianshu.com/p/949d44f3d9e3](https://www.jianshu.com/p/949d44f3d9e3)
[https://www.jianshu.com/p/7abc592f99e7](https://www.jianshu.com/p/7abc592f99e7)
https://www.jianshu.com/p/a9b2fec31fd1